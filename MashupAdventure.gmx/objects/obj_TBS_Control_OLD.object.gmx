<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// set up the grid and other such things

// whether we're on the map or in a battle
on_map = true;
delay_value = -1;
tea_break = 0;
randomize();

// start the grid empty
for(var i=0; i&lt;6; i++){
    for(var j=0; j&lt;8; j++){
        grid_obj[i,j] = -1;
        grid_tile[i,j] = -1;
    }
}

// variables
units = ds_list_create();
selecting = true;
whose_turn = 0; // 0-&gt;player, 1-&gt;enemy
curs_x = 0;
curs_y = 0;
curs_offset[0] = 0;
curs_offset[1] = 0;
frame_id = 0;
frame_id_temp = 0;
frame_id_temp_inc = 0.5;

// unit moving
transition = false;
unit_being_moved = -1;
unit_offset[0] = 0;
unit_offset[1] = 0;
unit_prev_xpos = 0;
unit_prev_ypos = 0;

// add tiles

// ship
grid_tile[1,1] = 5;
grid_tile[1,2] = 6;
grid_tile[2,2] = 7;
grid_tile[2,1] = 8;
// portal
grid_tile[6,4] = 4;

// add objects

// player
player = instance_create(32,16,obj_TBS_Unit);
player.type = "player";
player.xpos = 2;
player.ypos = 1;
player.HP = 25;
player.atk = 4;
ds_list_add(units,player);
grid_obj[1,2] = player;
// enemies
for(var i=0; i&lt;4; i++){
    var tempx = grid_obj[1,2].xpos;
    var tempy = grid_obj[1,2].ypos;
    while(!grid_empty_at(tempx,tempy)){
        tempx = irandom_range(0,7);
        tempy = irandom_range(0,5);
    }
    var temp = instance_create(tempx*16,tempy*16,obj_TBS_Unit);
    temp.type = "enemy";
    temp.xpos = tempx;
    temp.ypos = tempy;
    ds_list_add(units,temp);
    grid_obj[tempy,tempx] = temp;
}

// fight &lt;-&gt; map transitions
battle_enem = -1;
battle_play = -1;
battle_enemies[0] = -1;
battle_enemies[1] = -1;
battle_enemies[2] = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// use this when the game ends to prevent memory leaks
ds_list_destroy(units);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// control all the things

// update animation
if(frame_id_temp &lt; 1){
    frame_id_temp += frame_id_temp_inc;
}else if(frame_id &lt; 2){
    frame_id += 1;
    frame_id_temp = 0;
}else{
    frame_id = 0;
    frame_id_temp = 0;
}

if(tea_break == 0){

if(on_map){
    // map
    if(!transition){
    // check what turn it is
    if(whose_turn == 0){
        // player turn
        // if offsets are lerped
        if(curs_offset[0] == 0 &amp;&amp; curs_offset[1] == 0){
            // cursor controls
            if(key_left){
                // left
                if(curs_x &gt; 0){
                    curs_x -= 1;
                    curs_offset[0] = 16;
                }else{
                    curs_x = array_length_2d(grid_obj,0)-1;
                    curs_offset[0] = -(array_length_2d(grid_obj,0)-1)*16;
                }
            }
            if(key_right){
                // right
                if(curs_x &lt; array_length_2d(grid_obj,0)-1){
                    curs_x += 1;
                    curs_offset[0] = -16;
                }else{
                    curs_x = 0;
                    curs_offset[0] = (array_length_2d(grid_obj,0)-1)*16;
                }
            }
            if(key_up){
                // up
                if(curs_y &gt; 0){
                    curs_y -= 1;
                    curs_offset[1] = 16;
                }else{
                    curs_y = array_height_2d(grid_obj)-1;
                    curs_offset[1] = -(array_height_2d(grid_obj)-1)*16;
                }
            }
            if(key_down){
                // down
                if(curs_y &lt; array_height_2d(grid_obj)-1){
                    curs_y += 1;
                    curs_offset[1] = -16;
                }else{
                    curs_y = 0;
                    curs_offset[1] = (array_height_2d(grid_obj)-1)*16;
                }
            }
            if(key_A){
                // select
                // move
                transition = true;
                unit_being_moved = player;
                if(!grid_empty_at(curs_x,curs_y)){
                    if(grid_obj[curs_y,curs_x].type == "enemy"){
                        // set enemy
                        battle_enem = grid_obj[curs_y,curs_x];
                    }
                }
                // set grid
                grid_obj[curs_y,curs_x] = player;
                unit_offset[0] = (player.xpos - curs_x)*16;
                unit_offset[1] = (player.ypos - curs_y)*16;
                unit_prev_xpos = player.xpos;
                unit_prev_ypos = player.ypos;
                player.xpos = curs_x;
                player.ypos = curs_y;
            }
        }else{
            if(curs_offset[0] &gt; 0){
                curs_offset[0] -= 2;
            }
            if(curs_offset[0] &lt; 0){
                curs_offset[0] += 2;
            }
            if(curs_offset[1] &gt; 0){
                curs_offset[1] -= 2;
            }
            if(curs_offset[1] &lt; 0){
                curs_offset[1] += 2;
            }
        }
    }else{
        // enemy turns
        for(var i=0; i&lt;array_height_2d(grid_obj); i++){
            for(var j=0; j&lt;array_length_2d(grid_obj,i); j++){
                if(!grid_empty_at(j,i)){
                    if(grid_obj[i,j].type == "enemy"){
                        var ind = grid_obj[i,j];
                        // choose a random location
                        var targ_x = irandom_range(0,7);
                        var targ_y = irandom_range(0,5);
                        while(!grid_empty_at(targ_x,targ_y) &amp;&amp; grid_obj[targ_y,targ_x].type == "enemy"){
                            // redo the random
                            targ_x = irandom_range(0,7);
                            targ_y = irandom_range(0,5);
                        }
                        transition = true;
                        unit_being_moved = ind;
                        unit_offset[0] = (ind.xpos - targ_x)*16;
                        unit_offset[1] = (ind.ypos - targ_y)*16;
                        ind.xpos = targ_x;
                        ind.ypos = targ_y;
                    }
                }
            }
        }
    }
    
    }else{
        // lerp for unit movement
        if(unit_offset[0] != 0 || unit_offset[1] != 0){
            if(unit_offset[0] &gt; 0){
                unit_offset[0] -= 1;
            }
            if(unit_offset[0] &lt; 0){
                unit_offset[0] += 1;
            }
            if(unit_offset[1] &gt; 0){
                unit_offset[1] -= 1;
            }
            if(unit_offset[1] &lt; 0){
                unit_offset[1] += 1;
            }
        }else{
            // logic for after transition
            if(whose_turn == 0){
                // player logic
                if(curs_x == 0 &amp;&amp; curs_y == 0){
                    // portal cutscene
                }
                if(grid_obj[curs_y,curs_x].type == "enemy"){
                    // encounter
                    for(var i=0; i&lt;3; i++){
                        // generate enemies
                        var temp = instance_create(128+lengthdir_x(80,120*i),96+lengthdir_y(80,120*i),obj_TBS_Mob);
                        temp.array_ind = i;
                        battle_enemies[i] = temp;
                        if(instance_exists(obj_Pldn)){
                            with(obj_Pldn){
                                instance_destroy();
                            }
                        }
                        battle_play = instance_create(128,96,obj_Pldn);
                        show_debug_message("Made pldn (player)");
                        battle_play.HP = player.HP;
                        delay_value = false;
                        tea_break = 10;
                    }
                }
            }else{
                // enemy logic
                if(!grid_empty_at(targ_x,targ_y)){
                    if(grid_obj[targ_y,targ_x].type == "player"){
                        // encounter
                        battle_enem = unit_being_moved;
                        for(var i=0; i&lt;3; i++){
                            // generate enemies
                            var temp = instance_create(128+lengthdir_x(80,120*i),96+lengthdir_y(80,120*i),obj_TBS_Mob);
                            temp.array_ind = i;
                            battle_enemies[i] = temp;
                            if(instance_exists(obj_Pldn)){
                                with(obj_Pldn){
                                    instance_destroy();
                                }
                            }
                            battle_play = instance_create(128,96,obj_Pldn);
                            show_debug_message("Made pldn (enemy)");
                            battle_play.HP = player.HP;
                            delay_value = false;
                            tea_break = 10;
                        }
                    }
                    }
            }
            // end transition
            unit_being_moved = -1;
            transition = false;
        }
    }
}else{
    // fight
    if(battle_enemies[0] == -1 &amp;&amp; battle_enemies[1] == -1 &amp;&amp; battle_enemies[2] == -1){
        // transition
        on_map = true;
        player.HP = battle_play.HP;
        show_debug_message("Destroyed the player ^w^");
        with(battle_play){
            instance_destroy();
        }
        battle_play = -1;
        grid_obj[curs_x,curs_y] = player;
        grid_obj[unit_prev_xpos,unit_prev_ypos] = -1;
        // update turn
        if(whose_turn == 0){
            whose_turn = 1;
        }else{
            whose_turn = 0;
        }
    }
}

// update map status
if(delay_value != -1){
    on_map = delay_value;
    delay_value = -1;
}

}else{
    tea_break -= 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// tiles and such

// background
draw_sprite(spr_BG_Space,0,view_xview[0],view_yview[0]);

// tiles

if(on_map){
// tiles
for(var i=0; i&lt;array_height_2d(grid_tile); i++){
    for(var j=0; j&lt;array_length_2d(grid_tile,i); j++){
        if(grid_tile[i,j] != -1){
            draw_sprite(spr_Tiles_TBS,grid_tile[i,j],view_xview[0]+(16*i),view_yview[0]+(16*j));
        }
    }
}

// grid (if selecting)
if(!transition){
draw_sprite_tiled(spr_Tiles_TBS,9,view_xview[0],view_yview[0]);
}

// units
for(var i=0; i&lt;array_height_2d(grid_obj); i++){
    for(var j=0; j&lt;array_length_2d(grid_obj,i); j++){
        if(grid_obj[i,j] != -1){
            var temp = grid_obj[i,j];
            if(transition &amp;&amp; temp == unit_being_moved){
                if(temp.type == "player"){
                    if(temp.facing == 0){ // 11, 12, 13
                        draw_sprite(spr_Map_TBS,11+frame_id,(temp.xpos*16)+unit_offset[0],(temp.ypos*16)+unit_offset[1]);
                    }else{ // 8, 9, 10
                        draw_sprite(spr_Map_TBS,8+frame_id,(temp.xpos*16)+unit_offset[0],(temp.ypos*16)+unit_offset[1]);
                    }
                }else if(temp.type == "enemy"){
                    if(temp.facing == 0){ // 5, 6, 7
                        draw_sprite(spr_Map_TBS,5+frame_id,(temp.xpos*16)+unit_offset[0],(temp.ypos*16)+unit_offset[1]);
                    }else{ // 2, 3, 4
                        draw_sprite(spr_Map_TBS,2+frame_id,(temp.xpos*16)+unit_offset[0],(temp.ypos*16)+unit_offset[1]);
                    }
                }
            }else{
                if(temp.type == "player"){
                    if(temp.facing == 0){ // 11, 12, 13
                        draw_sprite(spr_Map_TBS,11+frame_id,temp.xpos*16,temp.ypos*16);
                    }else{ // 8, 9, 10
                        draw_sprite(spr_Map_TBS,8+frame_id,temp.xpos*16,temp.ypos*16);
                    }
                }else if(temp.type == "enemy"){
                    if(temp.facing == 0){ // 5, 6, 7
                        draw_sprite(spr_Map_TBS,5+frame_id,temp.xpos*16,temp.ypos*16);
                    }else{ // 2, 3, 4
                        draw_sprite(spr_Map_TBS,2+frame_id,temp.xpos*16,temp.ypos*16);
                    }
                }
            }
        }
    }
}

// cursor (if selecting) 14
draw_sprite(spr_Map_TBS,14,view_xview[0]+(16*curs_x)+curs_offset[0]-1,view_yview[0]+(16*curs_y)+curs_offset[1]-1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
